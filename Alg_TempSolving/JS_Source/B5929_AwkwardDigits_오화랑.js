/*
소 베시는 이제 막 서로 다른 염기 사이에서 숫자를 바꾸는 법을 배우고 있지만, 앞발굽 두 개 사이에 펜을 쉽게 잡을 수 없어 계속해서 오류를 범하고 있습니다.

베시는 숫자를 새로운 밑수로 변환해서 결과를 적을 때마다 항상 숫자 중 하나를 잘못 적습니다. 
예를 들어, 만약 그녀가 숫자 14를 이진법으로 변환한다면 (즉, 밑이 2인) 정확한 결과는 "1110"이어야 하지만, 대신 그녀는 "0110" 또는 "1111"을 적을 수 있습니다. 
베시는 실수로 숫자를 추가하거나 삭제하지 않기 때문에, 만약 이 숫자가 그녀가 틀린 숫자라면 앞자리가 "0"인 숫자를 적을 수 있습니다.

숫자 N을 밑수로 변환할 때 Bessie의 출력이 주어지면, N의 원래 값을 정확히 구하여라(밑수로 10). N은 기껏해야 10억이고, N에 대한 유일한 해가 존재한다고 가정할 수 있습니다.

이 개념들이 당신에게 새로운 것이라면, 당신이 원하는 base 2 및 base 3 번호에 관한 온라인 참조를 언제든지 상담하십시오.

입력
1행: 한 자리 숫자가 잘못 적혀 있는 N의 밑줄-2 표현입니다.
2행: N의 밑줄 3 표현이며, 한 자리 숫자가 잘못 적혀 있습니다.
출력
1행: N의 올바른 값입니다.
*/
// 14 -> 1110 , 112
// 1110 -> 0110, 1010, 1100, 1111 => 6, 8, 12, 15 ( 14 )
// 112 (14)-> 212, 122, 111 -> 14,
// 0 1 2, 10, 11, 12, 20, 21, 22, 100, 101, 102, 110, 111 ( 13 ), 112 ( 14 ), 120, 121, 122 (17), 200, 201, 202, 210, 211, 212 ( 23 ), 220, 221, 222, 300
// => 13 14 17 23
// 6, 8, 12, 15, 14
// 13, 14 17, 23
// => 14가 선택되어야 함.
const target = require('fs')
  .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
  .toString()
  .trim()
  .split('\n');

console.log(target);
let twoDigit = input[0];
let threeDigit = input[1];
for (let i = 0; i < twoDigit.length; i++) String.fromCodePoint;
